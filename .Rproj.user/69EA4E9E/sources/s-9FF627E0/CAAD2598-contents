#' MAVE for treatment iteraction
#' 
#' @param x input matrix of dimension nobs \times nvars. Each raw is a observation, each column is a covariate
#' @param y numeric response
#' @param tr is a vector of binary value representing two treatment, 0 or 1. 
#' @param c is the translating constant in the model, y=(T-c)g(x\beta)+f(x,\epsilon).
#' @param ini_method is the initial method for MAVE. One can choose 'multi' or 'sir' to obtain the initials.
#' @param method  'zero' or 'all' decides the local linear expansion only near zero or all data point.
#' @param h is the bandwidth of the kernal
#' @param tol is the convergence tolerence
#' @param maxit is the maxmum iteration
#' @return An object with S3 class "tiMAVE"
#' @import Rcpp
#' 
#' @export
#' iMAVEInfer for inference of the model effect modification
#' 
#' @param x input matrix of dimension nobs \times nvars. Each raw is a observation, each column is a covariate
#' @param y numeric response
#' @param tr is a vector of binary value representing two treatment, 0 or 1. 
#' @param method  'zero' or 'all' decides the local linear expansion only near zero or all data point. 'all' is default for imave and imave2.
#' @param monoLink indicates wehter the link function is assumed to be monotone. False by default.
#' @param mainEffect mainEffect is TRUE if iMAVE2; FALSE if iMAVE
#' @param initial selects the methds to obtain initial values. Default option "direct" start from 0; "zero" solves an imave with method='zero'
#' @param tol is the convergence tolerence
#' @param maxit is the maxmum iteration
#' @param normalizeWeight indicates whether the weight for kernels is normalized. Default is TRUE.
#' @param constraint indicates the constaint on B; by default, Grassmann Manifold
#' @return An object with S3 class "tiMAVE"
#' @import Rcpp
#' 
#' @export
#' 
iMAVEInfer <- function(fit, x, y, tr, pi, mainEffect = NULL, sampleSplitIndex = NULL, efficient = FALSE)
{
 d <- dim(fit$beta)[2]
 p <- dim(fit$beta)[1]
 n <- length(y)
 if (dim(fit$beta)[2] > 1){
   coef <- fit$beta %*% solve(fit$beta[1:d,1:d])
 } else {
   coef <- fit$beta/fit$beta[1]
 }
 
 ks <- function(xx, yy, xx.test){
   nobs <- nrow(xx)
   nvars <- ncol(xx)
   hopt <- (4/(nvars+2))^(1/(nvars+4)) * (nobs^(-1/(nvars+4)))
   wm <- function(t){
     if (ncol(xx)==1){
       weight <- exp(-0.5 * (as.numeric(t)-xx)^2/(hopt^2)) * hopt
     } else {
       weight <- apply(xx,1,function(s){exp(-0.5 * sum((t-s)^2)/(hopt^2)) * hopt^(ncol(xx))})
     }
     weighted.mean(yy, weight)
   }
   if (nrow(as.matrix(xx.test))==1) {
     yy.test <- wm(xx.test)
   } else {
     yy.test<- array(0,c(nrow(xx.test),1))
     for (index in 1:nrow(xx.test)){
       if (ncol(xx.test)==1){
         yy.test[index] <- wm(xx.test[index])
       } else {
         yy.test[index] <- wm(xx.test[index,])
       }
     }
   }
   yy.test
 }
 
 iMAVEpredict <- function(x.link){
   predict(shadow_model, newdata = data.frame(predictor = x.link),type='response')
 }
 
 exp_gam <- function(x, y){
    shadow_data <- data.frame(predictor = x, response = y)
    shadow_model <- lm(response~predictor, data = shadow_data)
    as.matrix(predict(shadow_model, newdata = data.frame(predictor = link),type='response'))
 }
 
 xNormalized <- function(x.test){
   pred.link <- x.test %*% coef
   train.link <- x %*% coef
   x.test.normalized <- x.test * 0
   for (i in 1:length(x.test)){
     x.test.normalized[i] <- ks(train.link,x[,i], pred.link)
   }
   x.test #- x.test.normalized
 }
 
 iMAVEgradient <- function(x.link){
   grad(iMAVEpredict, x.link)
 }
 
 # set sampleSplitIndex
 if(is.null(sampleSplitIndex)){
    sampleSplitIndex <- (rnorm(n) > 0)
 }
 
 link <- x %*% coef
 V <- rep(1, times=n)
 EV <- rep(1, times=n)
 if (efficient){
    V <- pi * (1-pi)
    EV <- exp_gam(link, V)
 }
 
 shadow_data <- data.frame(predictor = link[sampleSplitIndex], response = 2 * (tr[sampleSplitIndex]-0.5) * y[sampleSplitIndex]/(pi[sampleSplitIndex]*tr[sampleSplitIndex]+(1-pi[sampleSplitIndex])*(1-tr[sampleSplitIndex])))
 if(nrow(fit$ab)>=n){
   shadow_data$response <- fit$ab[sampleSplitIndex,1]
 }
 shadow_model <- mgcv::gam(response~predictor, data = shadow_data)
 g.value <- as.matrix(predict(shadow_model, newdata = data.frame(predictor = link),type='response'))
 g.gradient <- apply(link, 1, iMAVEgradient)
 EX <- apply(x, 2, function(t){exp_gam(link, V*t)})
 
 if (is.null(mainEffect)){
   residual <- y-g.value*(tr-0.5)
 } else {
   shadow_data <- data.frame(predictor = link[sampleSplitIndex], response = 0.5*y[sampleSplitIndex]/(pi[sampleSplitIndex]*tr[sampleSplitIndex]+(1-pi[sampleSplitIndex])*(1-tr[sampleSplitIndex])))
   shadow_model <- mgcv::gam(response~predictor, data = shadow_data)
   mainEffect <- predict(shadow_model, newdata = data.frame(predictor = link),type='response')
   residual<-(y-g.value*(tr-0.5)-as.matrix(mainEffect))
 }
 A_tmp <- zeros(d*(p-d))
 S_tmp <- zeros(d*(p-d), 1)
 B_tmp <- zeros(d*(p-d))
 for (iter in (c(1:n)[!sampleSplitIndex])){
   if (d==1){
     A.left_tmp <- t(kronecker(t(g.gradient[iter]), x[iter,-(1:d)]-EX[iter,-(1:d)]/EV[iter]))
   } else {
     A.left_tmp <- t(kronecker(t(g.gradient[,iter]), x[iter,-(1:d)]-EX[iter,-(1:d)]/EV[iter]))
   }
   A_tmp <- 1/4 * t(A.left_tmp) %*% (A.left_tmp)/(pi[iter]*tr[iter]+(1-pi[iter])*(1-tr[iter]))* (V[iter]) + A_tmp
   S_tmp <- t(A.left_tmp) * (tr[iter]-0.5) * residual[iter] /(pi[iter]*tr[iter]+(1-pi[iter])*(1-tr[iter])) * V[iter] + S_tmp
   B_tmp <- 1/4 * t(A.left_tmp) %*% (A.left_tmp)/(pi[iter]*tr[iter]+(1-pi[iter])*(1-tr[iter]))^2 * (residual[iter])^2 * (V[iter])^2 + B_tmp
 } 
 A <- A_tmp/sum(!sampleSplitIndex)
 S <- S_tmp/sum(!sampleSplitIndex)
 B <- B_tmp/sum(!sampleSplitIndex)
 covMatrix <- inv(A) %*% B %*% inv(A)
 coef_one_step <- rbind(eye(d), coef[-d,] + inv(A) %*% S)
 covMatrix_se <- rbind(zeros(d),matrix(sqrt(diag(covMatrix)),c(p-d,p-d)))
 res <- list(coef=coef, coef_one_step=coef_one_step, covMatrix=covMatrix,se=covMatrix_se)
 res
}

iMAVEInferAugment <- function(fit, x, y, tr, pi, mainEffect = NULL, efficient = FALSE){
   n <- length(y)
   sampleSplitIndex <- (rnorm(n)>0)
   
   fit1 <- iMAVEInfer(fit, x, y, tr, pi, mainEffect = mainEffect, sampleSplitIndex = sampleSplitIndex, efficient = efficient)
   fit2 <- iMAVEInfer(fit, x, y, tr, pi, mainEffect = mainEffect, sampleSplitIndex = !sampleSplitIndex, efficient = efficient)
   res <- list(coef=(fit1$coef + fit2$coef)/2, coef_one_step=(fit1$coef_one_step+fit2$coef_one_step)/2, se=sqrt((fit1$se^2 + fit2$se^2)/2)/sqrt(n))
   res
}

